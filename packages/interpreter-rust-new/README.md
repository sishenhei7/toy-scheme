rust 里面的闭包和 js 里面的闭包其实不一样：由于闭包里面捕获的变量其实是一个指向上面作用域的指针，但是无论用 Box、Rc 还是 RefCell 包裹，闭包捕获的变量都会在它的作用域结束的时候被销毁，除非这个变量是 static，但是不现实。而 js 或者 scheme 里面的闭包捕获的变量，在它自己所在的作用域结束的时候不会被销毁，所以不能用 rust 里面的闭包来代替 js 或者 scheme 里面的闭包。

那为什么不用 move 或者 clone 来表示闭包捕获的变量？move 的情况下，这个闭包只能使用一次，不现实；clone 的情况下，捕获的变量和原变量失去了关联。

所以考虑不用闭包捕获变量来表示 continuation，而是使用一个 struct 来表示。那么 continuation 从原来的 cps 结构转化为和 react fiber 类似的链式结构，通过 next 指针来实现控制流，并通过一个 map 来保存每个节点来实现节点的跳转和重复 interpreter（callcc）

这就是这个包的主要考虑。
